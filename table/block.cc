// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file. See the AUTHORS file for names of contributors.
//
// Decodes the blocks generated by block_builder.cc.

#include "table/block.h"

#include <algorithm>
#include <cstdint>
#include <vector>

#include "leveldb/comparator.h"
#include "table/format.h"
#include "util/coding.h"
#include "util/logging.h"

namespace leveldb {

// 读取Block最后的restart point length，获得保存的restart point个数
//（block最后一个变量存放的是restart_point的个数restart_point_length，与restart_point一样所占字节数是相同）
// 获取restart point length的头地址
inline uint32_t Block::NumRestarts() const {
  assert(size_ >= sizeof(uint32_t));
  return DecodeFixed32(data_ + size_ - sizeof(uint32_t));
}

// 初始化Block的三个地址：data_、restart offset、size_
// 错误处理，检查restart point length是否合法
Block::Block(const BlockContents& contents)
    : data_(contents.data.data()),
      size_(contents.data.size()),
      owned_(contents.heap_allocated) {

  // 防止size_ - sizeof(uint32_t)溢出
  // 同时防止NumRestarts()读取到Block前面的数据造成读取restart point出错
  if (size_ < sizeof(uint32_t)) {
    size_ = 0;  // Error marker
  } else {
    // 由于size_是size_t类型的，是非负数，如果size_ < sizeof(uint32_t)，那么size_ - sizeof(uint32_t) < 0会溢出
    size_t max_restarts_allowed = (size_ - sizeof(uint32_t)) / sizeof(uint32_t);
    if (NumRestarts() > max_restarts_allowed) {
      // The size is too small for NumRestarts()
      size_ = 0;
    } else {
      // 解析出restart array在data_中最开始位置的偏移量
      restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);
    }
  }
}

// 销毁
Block::~Block() {
  if (owned_) { // 如果data_内容是堆上创建而不是mmap的，需要销毁这段内容
    delete[] data_;
  }
}

// Helper routine: decode the next block entry starting at "p",
// storing the number of shared key bytes, non_shared key bytes,
// and the length of the value in "*shared", "*non_shared", and
// "*value_length", respectively.  Will not dereference past "limit".
//
// If any errors are detected, returns nullptr.  Otherwise, returns a
// pointer to the key delta (just past the three decoded values).
// Helper例程:解码从p开始的下一个块条目，分别存储共享密钥字节数、非共享密钥字节数以及*shared、*non-shared和*value length中值的长度。
// 将不解除引用超过限制。如果检测到任何错误，则返回nullptr。否则，返回一个指向键delta的指针(刚好经过三个解码值)。
static inline const char* DecodeEntry(const char* p, const char* limit,
                                      uint32_t* shared, uint32_t* non_shared,
                                      uint32_t* value_length) {
  if (limit - p < 3) return nullptr; // 不少于三个部分

  // 在小长度的情况下，避免跳入函数，减少栈空间创建
  *shared = reinterpret_cast<const uint8_t*>(p)[0];
  *non_shared = reinterpret_cast<const uint8_t*>(p)[1];
  *value_length = reinterpret_cast<const uint8_t*>(p)[2];

  // 如果三种长度都是只占一个字节
  if ((*shared | *non_shared | *value_length) < 128) {
    // Fast path: all three values are encoded in one byte each
    p += 3;
  } else { // 否则使用具体的函数解析变长int
    if ((p = GetVarint32Ptr(p, limit, shared)) == nullptr) return nullptr;
    if ((p = GetVarint32Ptr(p, limit, non_shared)) == nullptr) return nullptr;
    if ((p = GetVarint32Ptr(p, limit, value_length)) == nullptr) return nullptr;
  }
  
  // 如果剩下的空间都少于key和value的长度了，说明解析失败
  if (static_cast<uint32_t>(limit - p) < (*non_shared + *value_length)) {
    return nullptr;
  }
  return p;
}

class Block::Iter : public Iterator {
 private:
  const Comparator* const comparator_; // 要进行二分查找，一定要对比两个key的大小

  // Block的静态属性
  // 除了data_是地址，别的都是偏移量
  const char* const data_;       // underlying block contents, Block的头地址
  uint32_t const restarts_;      // Offset of restart array (list of fixed32), restart point的头偏移量
  uint32_t const num_restarts_;  // Number of uint32_t entries in restart array,restart point的个数，用于二分查找范围

  // current_ is offset in data_ of current entry.  >= restarts_ if !Valid
  uint32_t current_;  // Entry磁头：指向一组中某一Entry的磁头(偏移量) 
  uint32_t restart_index_;  // Index of restart block in which current_ falls , 组磁头：指向Block中某一组磁头（偏移量）
  
  // 临时变量
  std::string key_; // 读取到的key，需要用resize操作舍弃非共享部分，以减少数据拷贝
  Slice value_; // 读取到的value（注意这里是Slice，可以理解为它是指向data_的一个指针）
  Status status_; // 操作之后的状态

  // 封装二分查找要用的Compare
  inline int Compare(const Slice& a, const Slice& b) const {
    return comparator_->Compare(a, b);
  }

  // Return the offset in data_ just past the end of the current entry.
  // 获得下一个Entry的头偏移量
  inline uint32_t NextEntryOffset() const {
    return (value_.data() + value_.size()) - data_; // 注意value_是Slice类型的数据，它可以理解为指向data_某个value值开头的指针
  }

  // 获得组磁头的地址
  uint32_t GetRestartPoint(uint32_t index) {
    assert(index < num_restarts_);
    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));
  }

  // 移动组磁头和Entry磁头指向index组的第一个Entry
  void SeekToRestartPoint(uint32_t index) {
    key_.clear();
    restart_index_ = index;
    // current_ will be fixed by ParseNextKey();
    // ParseNextKey() starts at the end of value_, so set value_ accordingly
    // current_将由ParseNextKey()固定;
    // ParseNextKey()从value_的末尾开始，因此相应地设置value_

    // NextEntryOffset = data_ + offset + 0 - data_ = offset;
    // 为什么不通过更新current_的方式来重新定位呢？
    // current_ = offset
    // ParseNextKey()同一组时，value_的尾地址就是下一个Entry的开头地址
    // 利用这个特性，顺序ParseNextKey()可以很自然地进行下去
    // Seek的时候为了兼容它，也选择修改value_到offset
    uint32_t offset = GetRestartPoint(index);
    value_ = Slice(data_ + offset, 0);
  }

 public:
  Iter(const Comparator* comparator, const char* data, uint32_t restarts,
       uint32_t num_restarts)
      : comparator_(comparator),
        data_(data),
        restarts_(restarts),
        num_restarts_(num_restarts),
        current_(restarts_),
        restart_index_(num_restarts_) {
    assert(num_restarts_ > 0);
  }

  // 侦测到无效时，会使得磁头指向restarts_
  bool Valid() const override { return current_ < restarts_; }

  // 返回状态信息
  Status status() const override { return status_; }

  // 返回key
  Slice key() const override {
    assert(Valid());
    return key_;
  }

  // 返回value
  Slice value() const override {
    assert(Valid());
    return value_;
  }

  // 一直顺序遍历
  void Next() override {
    assert(Valid());
    ParseNextKey();
  }

  // 向前遍历一个Entry
  // 因为向前遍历的Entry有可能会在其它的组中，所以需要先找到向前遍历的Entry所在的组
  // 前一个Entry的头偏移量是小于当前Entry的头偏移量的
  // 这个组的第一个Entry的头偏移量是小于原Entry的头偏移量的
  // 而且是从右往左数第一个小于当前Entry的头偏移量的
  void Prev() override {
    assert(Valid());
    // Scan backwards to a restart point before current_
    // 向前扫描直到找到一个restart point，且位于current_之前
    const uint32_t original = current_;
    // 当前组的第一个Entry的头偏移量没有小于当前Entry的头偏移量，而是大于等于，说明我们要找的Entry不在这个组
    while (GetRestartPoint(restart_index_) >= original) {
      // 如果移到头了，还找不到，就不能再往前移了
      if (restart_index_ == 0) {
        // No more entries
        // 重置磁头
        current_ = restarts_;
        restart_index_ = num_restarts_;
        return; //说明找不到，前序遍历失败
      }
      // 向左移，寻找下一个可能的组
      restart_index_--;
    }

    // 移动到上一个Entry所在组的第一个Entry
    SeekToRestartPoint(restart_index_);

    // 向右顺序遍历，如果遍历到的Entry的尾偏移量大于等于原Entry的头偏移量，说明已经过了，肯定找不到
    do {
      // Loop until end of current entry hits the start of original entry
      // 循环，直到当前条目的末尾碰到原始条目的开始处
    } while (ParseNextKey() && NextEntryOffset() < original);
  }

  void Seek(const Slice& target) override {
    // Binary search in restart array to find the last restart point
    // with a key < target
    // 在重启数组中进行二进制搜索，查找具有key < target的最后重启点
    uint32_t left = 0;
    uint32_t right = num_restarts_ - 1;
    int current_key_compare = 0;

    // 减少比较次数
    if (Valid()) {
      // If we're already scanning, use the current position as a starting
      // point. This is beneficial if the key we're seeking to is ahead of the
      // current position.
      // 如果已经在扫描了，使用当前位置作为起点。如果你想要的key在当前位置的前面，这是有益的。
      current_key_compare = Compare(key_, target);
      if (current_key_compare < 0) {
        // key_ is smaller than target
        // key_ < target
        // key 属于[left, restart_index_ - 1]都 < target，且不是最后一个
        // 舍弃[left, restart_index_ - 1]，缩小到[restart_index_, right]
        left = restart_index_;
      } else if (current_key_compare > 0) {
        // key_ > target
        // target < key_
        // key_ 属于[restart_index_ + 1, right] 都 > target，不满足key < target
        // [header,...,target,...key_,...]，target还是有可能在本组内的
        // 舍弃[restart_index_ + 1, right]，缩小到[left, restart_index_]
        right = restart_index_;
      } else {
        // We're seeking to the key we're already at.
        // key_ = target
        // 我们上一次找到的Entry，restart_index_以及current_所指向的Entry，就是本次要找的Entry
        // 直接返回
        return;
      }
    }

    // 在restart_offset_ array数组中二分找到最后一个小于target的restart_offset_
    while (left < right) {
      uint32_t mid = (left + right + 1) / 2;
      uint32_t region_offset = GetRestartPoint(mid);
      uint32_t shared, non_shared, value_length;

      // data_ + region_offset为重启点的在块中开始位置，
      // data_ + restarts_为上边界，即restart_offset array最开始的位置
      const char* key_ptr =
          DecodeEntry(data_ + region_offset, data_ + restarts_, &shared,
                      &non_shared, &value_length);
      if (key_ptr == nullptr || (shared != 0)) {
        CorruptionError();
        return;
      }

      // restart point指向的都是组的第一个Entry，保存有完整的key，shared = 0
      Slice mid_key(key_ptr, non_shared);
      if (Compare(mid_key, target) < 0) {
        // Key at "mid" is smaller than "target".  Therefore all
        // blocks before "mid" are uninteresting.
        // [left, mid - 1]的key都满足key < target，但是肯定不是第一个，所以舍弃，留下[mid, right]
        left = mid;
      } else {
        // Key at "mid" is >= "target".  Therefore all blocks at or
        // after "mid" are uninteresting.
        // [mid, right]的key都满足key ≥ target，所以舍弃，留下[left, mid - 1]
        right = mid - 1;
      }
    }

    // We might be able to use our current position within the restart block.
    // This is true if we determined the key we desire is in the current block
    // and is after than the current key.
    // key_ < target [header,...,key_,...target...]   加速优化的过程
    // 同一组，且上一次ParseNextKey的key在这一次的前面，就可以直接ParseNextKey得到
    // key_ > target时，即使在同一组，target也在key_前面，无法ParseNextKey到
    assert(current_key_compare == 0 || Valid()); 
    bool skip_seek = left == restart_index_ && current_key_compare < 0;
    if (!skip_seek) {
      SeekToRestartPoint(left);
    }

    // Linear search (within restart block) for first key >= target
    while (true) {
      // 一直顺序遍历
      if (!ParseNextKey()) {
        return;
      }

      // 我们要找的是第一个key ≥ target的Entry
      // 读到大于等于target的key就返回
      if (Compare(key_, target) >= 0) {
        return;
      }
    }
  }

  // 移动并读取整个Block中第一个Entry的位置
  void SeekToFirst() override {
    SeekToRestartPoint(0);
    ParseNextKey();
  }

  // 移动并读取整个Block中最后一个Entry的位置
  void SeekToLast() override {
    // 移动到最后一组的第一个Entry
    SeekToRestartPoint(num_restarts_ - 1);
    // 向右顺序遍历，找到遍历到的Entry的尾偏移量大于等于Entry区的尾偏移量
    while (ParseNextKey() && NextEntryOffset() < restarts_) {
      // Keep skipping
    }
  }

 private:
  void CorruptionError() {
    // 重置磁头
    current_ = restarts_; //重置组磁头
    restart_index_ = num_restarts_; // 重置Entry磁头
    status_ = Status::Corruption("bad entry in block");
    key_.clear();
    value_.clear();
  }

  // 解析下一个Entry
  bool ParseNextKey() {
    current_ = NextEntryOffset(); // 更新current_,指向下一个要获取的Entry的开头位置
    const char* p = data_ + current_; // 计算restart point的开头地址
    const char* limit = data_ + restarts_;  // Restarts come right after data，边界位置
    // 如果下一个Entry的开头位置不在limit以内，则肯定读取不到Entry
    if (p >= limit) {
      // No more entries to return.  Mark as invalid.
      // 遍历完了
      current_ = restarts_;
      restart_index_ = num_restarts_;
      return false;
    }

    // Decode next entry
    // 从下一个Entry中解析出key的共享长度、key的非共享长度和value的长度，并将指针移动到非共享的key的位置
    uint32_t shared, non_shared, value_length;
    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);
    // 如果key的指针为空或者上一个key_还没到共享长度，那就拼接不起来完整的key
    if (p == nullptr || key_.size() < shared) {
      CorruptionError();
      return false;
    } else {
      // 去掉上一个key与当前key之间的非共享的部分
      key_.resize(shared);
      // 加上本次读取的本Entry的非共享的部分组成完整的key
      key_.append(p, non_shared);
      // 取出value
      value_ = Slice(p + non_shared, value_length);
      // 顺序遍历可能会遍历到下一个组中，导致restart_index和current_不匹配
      while (restart_index_ + 1 < num_restarts_ && // 不是最后一个组
             GetRestartPoint(restart_index_ + 1) < current_) { // current_移动到restart_index组右侧的组去了
        ++restart_index_;
      }
      return true;
    }
  }
};

Iterator* Block::NewIterator(const Comparator* comparator) {
  // 倘若size_ < sizeof(uint32_t)，则会导致data_ + size_ - sizeof(uint32_t) < data_
  // 调用NumRestarts()读取restart length肯定会出错
  if (size_ < sizeof(uint32_t)) {
    return NewErrorIterator(Status::Corruption("bad block contents"));
  }

  // 获得Block中的restart point的数量
  const uint32_t num_restarts = NumRestarts();

  // 如果为0，说明Block为空
  if (num_restarts == 0) {
    return NewEmptyIterator();
  } else { // 如果不为零，则说明Block正常，生成迭代器
    return new Iter(comparator, data_, restart_offset_, num_restarts);
  }
}

}  // namespace leveldb
